package com.gn.reminder.gateway.security;

import io.jsonwebtoken.JwtException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.stereotype.Component;

/**
 * Hybrid JWT Validator that supports both:
 * 1. Custom JWT tokens (generated by User Service)
 * 2. Keycloak JWT tokens (OAuth2/OIDC)
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class HybridJwtValidator {

    private final JwtUtil customJwtUtil;
    private final JwtDecoder keycloakJwtDecoder;

    @Value("${keycloak.enabled:true}")
    private boolean keycloakEnabled;

    /**
     * Validate JWT token - try custom JWT first, then Keycloak
     * Returns user info extracted from the token
     */
    public TokenInfo validateToken(String token) {
        // Try custom JWT first
        try {
            if (customJwtUtil.validateToken(token)) {
                log.debug("Valid custom JWT token");
                return extractCustomJwtInfo(token);
            }
        } catch (JwtException e) {
            log.debug("Not a custom JWT token, trying Keycloak: {}", e.getMessage());
        }

        // Try Keycloak JWT
        if (keycloakEnabled) {
            try {
                var jwt = keycloakJwtDecoder.decode(token);
                log.debug("Valid Keycloak JWT token");
                return extractKeycloakJwtInfo(jwt);
            } catch (org.springframework.security.oauth2.jwt.JwtException e) {
                log.debug("Not a valid Keycloak JWT token: {}", e.getMessage());
            }
        }

        throw new JwtException("Invalid token: not a valid custom or Keycloak JWT");
    }

    private TokenInfo extractCustomJwtInfo(String token) {
        var username = customJwtUtil.extractUsername(token);
        var userId = customJwtUtil.extractUserId(token);
        var email = customJwtUtil.extractEmail(token);
        
        return TokenInfo.builder()
                .userId(userId)
                .username(username)
                .email(email)
                .tokenType(TokenType.CUSTOM)
                .build();
    }

    private TokenInfo extractKeycloakJwtInfo(Jwt jwt) {
        var userId = jwt.getClaimAsString("sub");
        var username = jwt.getClaimAsString("preferred_username");
        var email = jwt.getClaimAsString("email");
        
        // Fallback to sub if preferred_username not available
        if (username == null) {
            username = userId;
        }
        
        return TokenInfo.builder()
                .userId(userId)
                .username(username)
                .email(email)
                .tokenType(TokenType.KEYCLOAK)
                .build();
    }

    public enum TokenType {
        CUSTOM, KEYCLOAK
    }

    @lombok.Data
    @lombok.Builder
    public static class TokenInfo {
        private String userId;
        private String username;
        private String email;
        private TokenType tokenType;
    }
}

